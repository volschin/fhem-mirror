# Comments start with #. Empty lines are ignored.
# Syntax of one entry: name: line, one optional filter: line, zero or more par: lines,  FHEM-Commands
# filter:INTERNAL=VALUE (optional)
# par: name of the parameter; comment; perl_code (optional)
# perl_code returns a value for the parameter, or undef.
# If undef, the user has to specify them (the comment is shown to the user)

###########################################
# zigbee2mqtt
# The zigbee2mqtt bridge device
name:zigbee2mqtt_bridge
filter:TYPE=MQTT2_DEVICE
par:BRIDGENAME;name of the zigbee2mqtt bridge in the topics
attr DEVICE setList\
  permit_join:true,false zigbee2mqtt/BRIDGENAME/config/permit_join $EVTPART1\
  remove:textField zigbee2mqtt/BRIDGENAME/config/remove $EVTPART1\
  log_level:debug,info,warn,error zigbee2mqtt/BRIDGENAME/config/log_level $EVTPART1\
  rename:textField zigbee2mqtt/BRIDGENAME/config/rename  {"old":"$EVTPART1","new":"$EVTPART2"}\
  network_map:raw,graphviz zigbee2mqtt/BRIDGENAME/networkmap  $EVTPART1\
  devicelist:noArg zigbee2mqtt/BRIDGENAME/config/devices


# A dimmable light connected via zigbee2mqtt
name:zigbee2mqtt_bulb
filter:TYPE=MQTT2_DEVICE
par:NAMEINTHEBRIDGE;name of this device in the bridge;{ AttrVal("DEVICE","readingList","") =~ m,zigbee2mqtt/(.*):, ? $1 : undef }
attr DEVICE icon light_control
attr DEVICE webCmd brightness
attr DEVICE setList \
  on:noArg zigbee2mqtt/NAMEINTHEBRIDGE/set {"state":"ON"}\
  off:noArg zigbee2mqtt/NAMEINTHEBRIDGE/set {"state":"OFF"}\
  brightness:colorpicker,BRI,0,15,255 zigbee2mqtt/NAMEINTHEBRIDGE/set {"state":"on","$EVTPART0":"$EVTPART1"}

# A dimmable color light connected via zigbee2mqtt
name:zigbee2mqtt_colorbulb
filter:TYPE=MQTT2_DEVICE
par:NAMEINTHEBRIDGE;name of this device in the bridge;{ AttrVal("DEVICE","readingList","") =~ m,zigbee2mqtt/(.*):, ? $1 : undef }
attr DEVICE icon light_control
attr DEVICE webCmd brightness:color_temp
attr DEVICE setList \
  on:noArg zigbee2mqtt/NAMEINTHEBRIDGE/set {"state":"ON"}\
  off:noArg zigbee2mqtt/NAMEINTHEBRIDGE/set {"state":"OFF"}\
  brightness:colorpicker,BRI,0,15,255 zigbee2mqtt/NAMEINTHEBRIDGE/set {"state":"on","$EVTPART0":"$EVTPART1"}\
  color_temp:colorpicker,CT,250,1,454 zigbee2mqtt/NAMEINTHEBRIDGE/set {"$EVTPART0":"$EVTPART1"}

name:zigbee2mqtt_colorbulbWithoutColorTemp
filter:TYPE=MQTT2_DEVICE
par:NAMEINTHEBRIDGE;name of this device in the bridge;{ AttrVal("DEVICE","readingList","") =~ m,zigbee2mqtt/(.*):, ? $1 : undef }
attr DEVICE icon hue_filled_white_and_color_e27_b22
attr DEVICE stateFormat {lc ReadingsVal("$name","state",0)}
attr DEVICE devStateIcon {devStateIcon255($name)}
attr DEVICE webCmd toggle:on:off:brightness:color
attr DEVICE setList \
  on:noArg zigbee2mqtt/NAMEINTHEBRIDGE/set {"state":"ON"}\
  off:noArg zigbee2mqtt/NAMEINTHEBRIDGE/set {"state":"OFF"}\
  brightness:colorpicker,BRI,0,15,255 zigbee2mqtt/NAMEINTHEBRIDGE/set {"state":"on","$EVTPART0":"$EVTPART1"}\
  color:colorpicker,RGB {"zigbee2mqtt/NAMEINTHEBRIDGE/set " . encode_json(convertRGBtoR_G_B($EVTPART1))}

name:zigbee2mqtt_smokeDetector
filter:TYPE=MQTT2_DEVICE
par:NAMEINTHEBRIDGE;name of this device in the bridge;{ AttrVal("DEVICE","readingList","") =~ m,zigbee2mqtt/(.*):, ? $1 : undef }
attr DEVICE icon secur_smoke_detector
attr DEVICE stateFormat smoke

name:zigbee2mqtt_hueMotionSensor
filter:TYPE=MQTT2_DEVICE
attr DEVICE stateFormat T: temperature_weather B: illuminance L: linkquality
attr DEVICE userReadings temperature_weather { sprintf("%.1f",ReadingsVal("DEVICE","temperature","")+2.5) }

name:zigbee2mqtt_smart+plug
filter:TYPE=MQTT2_DEVICE
par:NAMEINTHEBRIDGE;name of this device in the bridge;{ AttrVal("DEVICE","readingList","") =~ m,zigbee2mqtt/(.*):, ? $1 : undef }
attr DEVICE eventMap { dev=>{ON=>'on',OFF=>'off'} }
attr DEVICE setList \
  off zigbee2mqtt/NAMEINTHEBRIDGE/set OFF\
  on zigbee2mqtt/NAMEINTHEBRIDGE/set ON


###########################################
# TASMOTA
# The regexp must handle
# - tele/sonoff/LWT: => cmnd/sonoff/
# - DVES_XXXXXX:/SmartHome/Esszimmer/Stehlampe/tele/LWT: => /SmartHome/Esszimmer/Stehlampe/cmnd/
name:tasmota_basic
filter:TYPE=MQTT2_DEVICE
par:COMMAND;Command topic prefix, without trailing /;{ AttrVal("DEVICE","readingList","") =~ m,([^:]*)\btele(/.*)?/LWT:, ? "${1}cmnd$2" : undef }
attr DEVICE stateFormat {lc ReadingsVal("$name","POWER","") }
attr DEVICE eventMap { dev=>{'^(.*)POWER: OFF$'=>'$1POWER: off', '^(.*)POWER: ON$'=>'$1POWER: on'} }
attr DEVICE setList \
  off:noArg    COMMAND/POWER1 0\
  on:noArg     COMMAND/POWER1 1\
  toggle:noArg COMMAND/POWER1 2

# sonoff 1 channel device flashed with Tasmota.
name:tasmota_1channel
filter:TYPE=MQTT2_DEVICE
par:COMMAND;Command topic prefix, without trailing /;{ AttrVal("DEVICE","readingList","") =~ m,([^:]*)\btele(/.*)?/LWT:, ? "${1}cmnd$2" : undef }
attr DEVICE eventMap { dev=>{'^(.*)POWER(.?): OFF$'=>'$1POWER$2: off', '^(.*)POWER(.?): ON$'=>'$1POWER$2: on'} }
attr DEVICE stateFormat {lc ReadingsVal("$name","POWER1","")}
attr DEVICE setList \
  off:noArg    COMMAND/POWER1 0\
  on:noArg     COMMAND/POWER1 1\
  toggle:noArg COMMAND/POWER1 2

# sonoff 2 channel device flashed with Tasmota.
# NOTE: a second device will be created for the second channel
name:tasmota_2channel
filter:TYPE=MQTT2_DEVICE
par:COMMAND;Command topic prefix, without trailing /;{ AttrVal("DEVICE","readingList","") =~ m,([^:]*)\btele(/.*)?/LWT:, ? "${1}cmnd$2" : undef }
attr DEVICE eventMap { dev=>{'^(.*)POWER(.?): OFF$'=>'$1POWER$2: off', '^(.*)POWER(.?): ON$'=>'$1POWER$2: on'} }
attr DEVICE stateFormat {lc ReadingsVal("$name","POWER1",0)}
attr DEVICE setList \
  off:noArg    COMMAND/POWER1 0\
  on:noArg     COMMAND/POWER1 1\
  toggle:noArg COMMAND/POWER1 2
attr DEVICE comment Channel 1 for DEVICE, see also DEVICE_CH2
copy DEVICE DEVICE_CH2
attr DEVICE_CH2 stateFormat {lc ReadingsVal("$name","POWER2","")}
attr DEVICE_CH2 comment Channel 2 for DEVICE
attr DEVICE_CH2 setList \
  off:noArg    COMMAND/POWER2 0\
  on:noArg     COMMAND/POWER2 1\
  toggle:noArg COMMAND/POWER2 2
